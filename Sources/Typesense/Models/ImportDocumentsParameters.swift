//
// ImportDocumentsParameters.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct ImportDocumentsParameters: Codable {

    public var action: IndexAction?
    public var batchSize: Int?
    public var dirtyValues: DirtyValues?
    public var remoteEmbeddingBatchSize: Int?
    public var returnDoc: Bool?
    /** Returning the id of the imported documents. If you want the import response to return the ingested document's id in the response, you can use the return_id parameter. */
    public var returnId: Bool?

    public init(action: IndexAction? = nil, batchSize: Int? = nil, dirtyValues: DirtyValues? = nil, remoteEmbeddingBatchSize: Int? = nil, returnDoc: Bool? = nil, returnId: Bool? = nil) {
        self.action = action
        self.batchSize = batchSize
        self.dirtyValues = dirtyValues
        self.remoteEmbeddingBatchSize = remoteEmbeddingBatchSize
        self.returnDoc = returnDoc
        self.returnId = returnId
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case action
        case batchSize = "batch_size"
        case dirtyValues = "dirty_values"
        case remoteEmbeddingBatchSize = "remote_embedding_batch_size"
        case returnDoc = "return_doc"
        case returnId = "return_id"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(action, forKey: .action)
        try container.encodeIfPresent(batchSize, forKey: .batchSize)
        try container.encodeIfPresent(dirtyValues, forKey: .dirtyValues)
        try container.encodeIfPresent(remoteEmbeddingBatchSize, forKey: .remoteEmbeddingBatchSize)
        try container.encodeIfPresent(returnDoc, forKey: .returnDoc)
        try container.encodeIfPresent(returnId, forKey: .returnId)
    }
}
